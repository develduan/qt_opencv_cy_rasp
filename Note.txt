NOTE :
opencv 中的位操作都是用0和255来代表逻辑值不是0和1

---还有很多可以优化的地方---
1.现在的二值化采取的是简单的灰度化的值，特征值是亮度，太过单一，分化度不高
	如果将图像转化到HSV或者YCrCb色域上，通过三个通道的阈值进行二值化可以达到到比较好的分化，
	肤色提取也可用此方法，效果中等偏上

2.二值化后需要一系列的边缘缩进和寻找白点（或者黑点），现在采取简单的从头遍历，但是事实上应该
	可以保存上一次找到的点，作为此次的遍历开始点，可以降低时间复杂度

3.在进行二值图边缘提取的时候有一点特别需要注意：
	opencv中的提取边缘函数有个问题就是存在"与运算缩扩"
	即：提取的边缘与原图像（或原图像的取反）进行与运算，---（*）
	得到的图像再次进行（*）操作，图像的黑色（或者白色）会不断的缩进或者扩展
	导致得到错误低效的坐标点，这应该是因为opencv的边缘提取基本上都是以求导预算为基本运算得到
	边缘的，所以写了一个自己的‘四方向二值图边缘检测’【cv::Mat edgesbw(cv::Mat imgbw)】克服这种现象。


4.现在的程序都是以圆形为冲压图像的，但是转化到无旋转的正方形和正六边形原理是不变的，是需要改少量的代码，
	就是边缘缩进的代码需要修改（原理在纸质推导上）

5.关于上下左右边缘的处理还不太清楚具体要求，但是如果要把这四个边缘考虑到随边缩进来，只要在得到二值图后把
	二值图的上下左右四个行/列的颜色置为白色值（不是材料的颜色值）就可以了，在opencv中简单几条语句就可以实现。

6.程序仓促有很多要优化的地方。。。




/*
%% 算法原理
%{
#1 得到扫描二值图
#2 按照半径内缩腐蚀，得到首个圆心区域
#3 检测圆心区域是否存在，否则退出
#4 在圆形区域边缘左侧选取一点P，打印P点坐标
#5 减去P点圆心，2r半径的圆，得到新的圆心区域，重复#3, 4, 5步骤
%}
*/



/*排序
{
1.原始，从左到右
2.采用s形状路线
3.欧几里得距离 ->目前暂时采用这种
}
*/